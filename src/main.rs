mod words;

use clap::Parser;
use words::WORDS;

/// Generate diceware-like passphrases
#[derive(Parser)]
#[clap(version = "0.1.0")]
struct Arguments {
    /// The number of words a passphrase shall be made up of
    #[clap(
        short = 'w',
        long = "words",
        value_name = "n",
        required = false,
        default_value = "4"
    )]
    num_words: usize,

    /// The number of passphrases to generate
    #[clap(
        short = 'n',
        long = "passphrases",
        value_name = "n",
        required = false,
        default_value = "1"
    )]
    num_passwords: usize,

    #[clap(short = 'd', long = "delimiter", default_value = " ")]
    delimiter: String,

    /// Print nothing but the passphrase (implied when -n is used)
    #[clap(short = 'q', long = "quiet")]
    quiet: bool,
}

/// Roll `n` dice and collect the results into a vector.
fn roll_dice(n: usize) -> Vec<u8> {
    use rand::distributions::Standard;
    use rand::Rng;

    rand::thread_rng()
        .sample_iter(Standard)
        .take(n)
        .map(|i: u8| i % 6 + 1)
        .collect()
}

/// Translate the diceware key to an index
///
/// A "diceware key" in this case is a set of 5 die-throw-results. To translate this to an index,
/// we subtract one from each throw, and then treat these as a base-6 number. That gives us the
/// index into the word list, eliminating the need for a map of some kind.
///
/// # Examples
///
/// If our throws are `[6, 5, 4, 3, 2]`, we subtract one from each, and then combine them into a
/// single number, 54321. When treated as base-6, this number is equal to 7465 in base-10, which is
/// our index into the word-list.
fn to_index(key: &Vec<u8>) -> usize {
    key.iter()
        .rev()
        .enumerate()
        .map(|(pow, &n)| (n as usize - 1) * 6_usize.pow(pow as u32))
        .sum()
}

/// Get a random word from the word list. The index is generated by throwing 5 dice.
///
/// Of course, a word could just be picked by generating a single random number in the range [0,
/// list length), but then it wouldn't be diceware.
fn get_word<'a>() -> &'a str {
    let key = roll_dice(5);
    let index = to_index(&key);
    WORDS[index]
}

/// Generate a passphrase made up of `n` words
fn gen_passphrase(n: usize, delimiter: &str) -> String {
    (0..n)
        .map(|_| get_word())
        .collect::<Vec<&str>>()
        .join(delimiter)
}

fn main() {
    let args = Arguments::parse();

    if args.num_passwords > 1 {
        for _ in 0..args.num_passwords {
            println!("{}", gen_passphrase(args.num_words, &args.delimiter));
        }

        return;
    }

    let password = gen_passphrase(args.num_words, &args.delimiter);

    if args.quiet {
        println!("{}", password);
        return;
    }

    let possible_combinations = (WORDS.len() as f64).powf(args.num_words as f64);
    let power_of_ten = possible_combinations.log10().floor() as u64;

    println!("Your password is:");
    println!();
    println!("\t{}", password);
    println!();
    println!(
        "This password is one of about 10^{} possible combinations.",
        power_of_ten
    );
}

#[cfg(test)]
mod tests {
    use crate::*;

    #[test]
    fn test_to_index() {
        let key = vec![1, 1, 1, 1, 1];
        assert_eq!(to_index(&key), 0);

        let key = vec![1, 2, 3, 4, 5];
        assert_eq!(to_index(&key), 310);

        let key = vec![6, 6, 6, 6, 6];
        assert_eq!(to_index(&key), 7775);
    }

    #[test]
    fn test_get_word() {
        use std::collections::HashMap;

        let iterations = 1_000_000;
        let expected_mean = iterations / WORDS.len();

        let mut word_occurrences = HashMap::new();
        for word in WORDS.iter() {
            word_occurrences.insert(*word, 0);
        }

        for _ in 0..iterations {
            let word = get_word();
            let count = word_occurrences.entry(word).or_insert(0);
            *count += 1;
        }

        for (_, count) in word_occurrences {
            assert!(count < (expected_mean as f64 * 1.5) as usize);
            assert!(count > (expected_mean as f64 * 0.5) as usize);
        }
    }

    #[test]
    fn test_gen_passphrase() {
        for n in 1..50 {
            let pw = gen_passphrase(n, " ");
            assert!(pw.split(' ').collect::<Vec<_>>().len() == n);
        }
    }
}
